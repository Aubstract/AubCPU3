import Line
import dictionaries as dicts
import error_check as err


def construct_lines(program: list[str]) -> list[object]:
    """Takes a list of strings and creates a list of objects, each with two attributes:
       - The line of program (str)
       - The line number (int)
       This allows the error-checker to specify the line number in an error message"""
    lines = []

    for line_num, line in enumerate(program):
        lines.append(Line.Line(line, line_num + 1))

    return lines


def sanitize(program: list[object]):
    """Eliminates comments, empty lines, tabs, double spaces, etc"""

    for line_num, line_object in reversed(list(enumerate(program))):

        line = line_object.line

        while '\t' in line:
            line = line.replace('\t', '')
        while "  " in line:
            line = line.replace("  ", ' ')
        while ',' in line:
            line = line.replace(',', '')

        if "//" in line:
            line = line[: line.index("//")]
        if line.startswith(" "):
            line = line[1:]
        if line.endswith(" "):
            line = line[:-1]
        if "\n" in line:
            line = line[: line.index("\n")]
        if "link" in line:
            line = ""

        if len(line) == 0:
            program.pop(line_num)
        else:
            program[line_num].line = line


def remove_labels(program: list[object]):
    """Removes lines with label definitions"""
    for index, line_object in reversed(list(enumerate(program))):
        if ':' in line_object.line:
            program.pop(index)


def replace_labels_in_expression(line: str, line_index: int) -> str:
    """Replaces inline uses of labels with their associated value"""
    expression = line[line.index(':') + 1:]
    tokens = expression.split()

    for index, token in enumerate(tokens):
        if token in dicts.jump_labels:
            tokens[index] = dicts.jump_labels[token]
        elif token in dicts.var_labels:
            tokens[index] = dicts.var_labels[token]
        elif token == '.':
            tokens[index] = str(line_index)

    return ' '.join(tokens)


def evaluate_rpn(expr: str) -> str:  # Generated by Google Gemini
    """
    Evaluates a reverse polish notation expression.
    Args:
        expr: A string containing the expression in reverse polish notation.
    Returns:
        A string containing the integer value of the expression.
    Raises:
        ValueError: If the expression is invalid.
    """
    stack = []
    for token in expr.split():
        if token.isdigit():
            stack.append(int(token))
        else:
            try:
                operand2 = stack.pop()
                operand1 = stack.pop()
                if token == "+":
                    result = operand1 + operand2
                elif token == "-":
                    result = operand1 - operand2
                elif token == "*":
                    result = operand1 * operand2
                elif token == "/":
                    if operand2 == 0:
                        raise ValueError("Division by zero")
                    result = operand1 // operand2  # Use integer division for integer result
                else:
                    raise ValueError("Invalid operator: " + token)
                stack.append(result)
            except IndexError:
                raise ValueError("Invalid expression")
    if len(stack) != 1:
        raise ValueError("Invalid expression")
    return str(int(stack.pop()))  # Convert result to int and return as string


def construct_labels(program: list[object]):
    """Adds all labels to the label dictionaries, as well as calculates their values"""
    line_index = 0
    for line_object in program:
        if ':' in line_object.line:
            if line_object.line.endswith(':'):
                jump_addr = line_index - 1
                if jump_addr == -1:
                    jump_addr = 255
                dicts.jump_labels[line_object.line[:-1]] = str(jump_addr)
                line_index -= 1
            else:
                err.check_expression(line_object)
                expression = replace_labels_in_expression(line_object.line, line_index)
                expression = evaluate_rpn(expression)
                dicts.var_labels[line_object.line[:line_object.line.index(':')]] = expression
                line_index -= 1
        line_index += 1
    remove_labels(program)


def evaluate_inline_expressions(program: list[object]) -> list[object]:
    for line_object in program:
        if '(' in line_object.line and ')' in line_object.line:
            expr_left = line_object.line.find('(')
            expr_right = line_object.line.find(')')

            expression = line_object.line[expr_left + 1: expr_right]
            expression = expression.split()
            for index, token in enumerate(expression):
                if token in dicts.var_labels:
                    expression[index] = dicts.var_labels[token]
                elif token in dicts.jump_labels:
                    expression[index] = dicts.jump_labels[token]
            expression = ' '.join(expression)
            expression = evaluate_rpn(expression)
            expression = line_object.line[:expr_left] + expression + line_object.line[expr_right + 1:]
            line_object.line = expression
            pass


def replace_inline_labels_with_literals(program: list[object]):
    for line_object in program:
        line = line_object.line
        tokens = line.split()

        for index, token in enumerate(tokens):
            if token in dicts.var_labels:
                tokens[index] = dicts.var_labels[token]
            elif token in dicts.jump_labels:
                tokens[index] = dicts.jump_labels[token]
            elif token in dicts.register_names:
                tokens[index] = dicts.register_names[token]
            elif token in dicts.alt_register_names:
                tokens[index] = dicts.alt_register_names[token]
        line_object.line = ' '.join(tokens)

    return program


def preprocess(program: list[str]) -> list[object]:
    # Construct Line objects
    new_program = construct_lines(program)
    # Remove comments, whitespace etc
    sanitize(new_program)
    # Construct labels
    construct_labels(new_program)
    evaluate_inline_expressions(new_program)
    # Check for undefined labels
    err.check_if_all_labels_are_defined(new_program)
    # Check that opcodes have the right number of operands
    err.check_opcodes_and_operands(new_program)
    # Replace labels with their associated value
    replace_inline_labels_with_literals(new_program)
    return new_program
